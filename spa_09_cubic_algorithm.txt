
============================================================
[SPA BOOK] 9.2 큐빅 알고리즘 (The Cubic Algorithm)

[개요]

정적 분석 (static analysis)는 프로그램을 실행하지 않고 코드를 보고
특정 성질을 분석하는 방법이다.

정적 분석 방법은 보통 두 단계로 나누어 진행한다. 1단계에서 프로그램
코드에서 제약식 (constraint equations)을 생성하고, 2단계에서 이
제약식의 해 (solution)를 구하여 특정 성질을 분석한다. 두 번째 단계에서
제약식을 푸는 알고리즘이 필요하다.

다양한 정적 분석 방법에서 제약식의 형태가 다를 수 있고 푸는 알고리즘이
다를 수 있지만, 일반적으로 공통된 형태의 제약식과 공통된 알고리즘을
사용하곤 한다. 큐빅 알고리즘은 많이 사용되는 공통 알고리즘이다.

큐빅 알고리즘에서 다루는 제약식은 다음과 같은 형태를 띄고 있다.

 - 유한개의 토큰 집합 T = {t1, ..., tk}
 - 유한개의 변수 집합 V = {x1, ..., xn}

 - 각 변수들은 T의 부분집합을 해로 갖는다.

 - 제약식 C := t \in x
              (토큰 t는 변수 x의 집합의 원소)
	      
            | t \in x => y \subseteq z
	      (토큰 t가 x의 원소이면 y의 집합에 있는 모든
	      원소는 z의 집합에 속한다.)

큐빅 알고리즘은 이러한 형태의 제약식을 받아 변수들의 최소 해 (minimal
solution)를 구한다.

Exercise: 다음 집합식에서 해와 최소 해의 차이점을 예를 들어 설명하시오.

  X = Y \cup { a }
  Y = X \cup { b }


[큐빅 알고리즘]

큐빅 알고리즘은 DAG (directed acyclic graph)를 사용한다.

DAG의 노드와 에지는 다음과 같이 구성한다.

 - n개 변수에 해당하는 노드를 둔다.
 
 - 각 노드에 k개 토큰을 0과 1로 표시할 수 있는 비트 벡터 (bitvector)의
   속성을 둔다.

 - 각 비트마다 변수 쌍 (x,y) 리스트를 둔다. 아래 보충 설명을 참고한다.

 - 두 노드 사이의 방향성 에지 (directed edge)로 연관된 두 변수 사이의
   포함 관계를 나타낸다.

첫 번째 형태의 제약식 ti \in xj를 확인하려면 변수 xj에 해당하는 j번째
노드를 찾아서 토큰 ti에 해당하는 i번째 비트가 1인지 보면 된다.

두 번째 형태의 제약식 ti \in xj => y \subseteq z은 DAG에서 다음과 같이
나타낸다.

 - 노드 xj의 i번째 비트가 1이면, 이 비트가 가리키는 리스트에서 (y,z)를
   삭제하고 y에 해당하는 노드에서 z에 해당하는 노드로 향하는 에지를
   추가한다.

 - 만일 노드 xj의 i번째 비트가 0이면, 이 비트가 가리키는 리스트에
   (y,z)를 둔다.

새로 추가한 에지로 사이클이 형성되면 이 사이클을 구성하는 모든
노드들을 하나의 노드로 합한다. 각 노드들이 가지고 있던 비트 벡터들을
OR시키고, 각 비트에 연결된 변수 쌍 리스트들은 비트별로 모은다.

 - 알고리즘을 시작할 때는 각 변수당 노드를 1개씩 두는 형태지만
   진행하면서 두 변수가 1개의 노드를 공유할 수 있는 형태가 될 수
   있다. 이점을 고려해서 변수와 노드간의 매핑 자료 구조를
   설계해야한다.

여러 노드의 동일 위치의 비트를 모은 다음 DAG의 에지를 따라 비트 벡터
값들을 전파시킨다.

이 과정을 더이상 새로운 변경 사항이 생기지 않을 때까지 반복한다.

이 반복이 끝날 때 얻은 각 노드의 비트 벡터에 1로 설정된 토큰들의
집합이 해당 노드로 표현한 변수의 최소 해가 된다.


Exercise: 큐빅 알고리즘의 시간 복잡도 O(n^3)을 설명하시오.

 - 교재 설명 참고.


Exercise: 에지를 통해 비트 벡터를 전파하는 방법으로 에지로 연관된 두
비트 사이에 비트 와이어 (bit wire)를 두는 방법을 조사하시오.

 - 교재 설명 참고.

Exericse: SPA 강의노트의 Scala 기반 구현을 실행해보시오.

 - https://cs.au.dk/~amoeller/spa/
 - https://github.com/cs-au-dk/TIP
   .../src/tip/solvers/CubicSolver.scala

 - https://cs.au.dk/~amoeller/spa/8-control-flow-analysis.pdf
   [Slide]

--------------------------------------------------------------

[예제]

 - 유한개의 토큰 집합 T = {t1, ..., tk}
 - 유한개의 변수 집합 V = {x1, ..., xn}

  변수 xi: 토큰들의 집합

  T = { t1, t2, t3, t4, t5 }
  V = { x1, x2, x3 }

문제(problem) : 제약식

 - t3 \in x1          : 토큰(원소) t3이 집합 x1에 속한다!
  
 - x1 \subseteq x2    : 집합 x1에 포함된 모든 원소가 집합 x2에 포함된다!
  
 - t3 \in x2          : 집합 x2에 t가 포함되면 x3의 모든 원소를 x4에 전달!
     ===> x3 \subseteq x1

 - t1 \in x2          : 
     ===> x3 \subseteq x2

 - t1 \in x3

해(solution)

  x1 = { t1, t3 }
  x2 = { t1, t3 }

  새로운 제약식 : x3 \subseteq x4  왜? t3가 x2에 포함되었기 때문에!

  x3 = { t1 }
  x4 = { t1 } 


Cubic framework

 - 3가지 유형의 제약식을 표현하는 방법:
    그래프 G = (노드, 에지)
        노드 : 변수들의 집합 V
	   노드의 속성: ti \in xj 제약식 마다 ti를 xj에 가지고 있다!
	             (비트 벡터 bitvector)
	   
	에지 : xi \subseteq xj 제약식 마다 xi에서 xj로 가는 에지를 둔다!
	

   


